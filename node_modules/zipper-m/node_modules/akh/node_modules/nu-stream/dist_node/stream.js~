"use strict";
var end, NIL, stream, memoStream, cons, append, appendz, concat, from, first, rest, isEmpty, isStream, forEach, reverse,
        foldl, foldr, reduce, reduceRight, toArray, zip, indexed, map, filter, bind, arrayReduce = Function.prototype.call
        .bind(Array.prototype.reduce),
    constant = ((x) {
        return (() {
            return x;
        });
    }),
    flip = ((f) {
        return ((x, y) {
            return f(y, x);
        });
    }),
    memo = ((f) {
        var value;
        return (() {
            var args = arguments;
            if ((value === undefined))(value = f.apply(undefined, args));
            return value;
        });
    });
(end = null);
(NIL = end);
(stream = ((val, f) {
    return ({
        "first": val,
        "rest": f
    });
}));
(memoStream = ((val, f) {
    return stream(val, memo(f));
}));
(first = ((s) {
    return s.first;
}));
(rest = ((s) {
    return s.rest(first(s));
}));
(isEmpty = ((s) {
    return (s === end);
}));
(isStream = ((s) {
    return (((s && s.hasOwnProperty("first")) && s.hasOwnProperty("rest")) || (s === end));
}));
(cons = ((val, s) {
    return stream(val, constant(s));
}));
(appendz = ((s1, f) {
    return (isEmpty(s1) ? f() : memoStream(first(s1), appendz.bind(null, rest(s1), f)));
}));
var reducer = ((s1, s2) {
    return appendz(s1, constant(s2));
});
(append = (() {
    var streams = arguments;
    return arrayReduce(streams, reducer, end);
}));
(concat = ((s) {
    return (isEmpty(s) ? s : appendz(first(s), concat.bind(null, rest(s))));
}));
var fromImpl = ((arr, i, len) {
    return ((i >= len) ? end : memoStream(arr[i], fromImpl.bind(null, arr, (i + 1), len)));
});
(from = ((arr) {
    var length = arr["length"];
    return fromImpl(arr, 0, length);
}));
(zip = ((l1, l2) {
    return ((isEmpty(l1) || isEmpty(l2)) ? end : memoStream([first(l1), first(l2)], zip.bind(null, rest(l1),
        rest(l2))));
}));
var count = ((n) {
    return stream(n, ((f, g) {
        return ((x) {
            return f(g(x));
        });
    })(count, ((x, y) {
            return (x + y);
        })
        .bind(null, 1)));
});
(indexed = zip.bind(null, count(0)));
(forEach = ((f, s) {
    for (var head = s; !isEmpty(head);
        (head = rest(head))) f(first(head));
}));
(foldl = ((f, z, s) {
    var r = z;
    forEach(((x) {
        (r = f(r, x));
    }), s);
    return r;
}));
(reverse = foldl.bind(null, flip(cons), end));
(foldr = ((f, z, s) {
    return foldl(f, z, reverse(s));
}));
(reduce = ((f, s) {
    return foldl(f, first(s), rest(s));
}));
(reduceRight = ((f, s) {
    return reduce(f, reverse(s));
}));
var builder = ((p, c) {
    p.push(c);
    return p;
});
(toArray = ((s) {
    return foldl(builder, [], s);
}));
(map = ((f, s) {
    return (isEmpty(s) ? s : memoStream(f(first(s)), map.bind(null, f, rest(s))));
}));
(filter = ((pred, s) {
    var head = s;
    for (; !isEmpty(head);
        (head = rest(head))) {
        var x = first(head);
        if (pred(x)) return memoStream(x, filter.bind(null, pred, rest(head)));
    }
    return head;
}));
(bind = ((f, g) {
    return (() {
        return f(g.apply(null, arguments));
    });
})(concat, map));
(exports.end = end);
(exports.NIL = NIL);
(exports.stream = stream);
(exports.memoStream = memoStream);
(exports.cons = cons);
(exports.append = append);
(exports.appendz = appendz);
(exports.concat = concat);
(exports.from = from);
(exports.first = first);
(exports.rest = rest);
(exports.isEmpty = isEmpty);
(exports.isStream = isStream);
(exports.forEach = forEach);
(exports.reverse = reverse);
(exports.foldl = foldl);
(exports.foldr = foldr);
(exports.reduce = reduce);
(exports.reduceRight = reduceRight);
(exports.toArray = toArray);
(exports.zip = zip);
(exports.indexed = indexed);
(exports.map = map);
(exports.filter = filter);
(exports.bind = bind);